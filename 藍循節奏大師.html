<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <title>藍循節奏大師：最終版</title>
    <style>
        :root {
            /* Palette */
            --bg-dark: #020617;
            --bg-panel: rgba(15, 23, 42, 0.6);
            --accent-cyan: #00f3ff;
            --accent-green: #00ff88;
            --accent-yellow: #ffdd00;
            --accent-orange: #ff9100;
            --accent-red: #ff0055;
            --accent-purple: #d946ef;
            --accent-crimson: #be123c;
            
            --text-primary: #ffffff;
            --text-secondary: #94a3b8;
            
            --glass-border: rgba(255, 255, 255, 0.15);
            --blur: blur(20px);
        }

        body {
            margin: 0;
            background-color: var(--bg-dark);
            background: linear-gradient(-45deg, #0f0c29, #302b63, #24243e, #0f0c29);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            color: var(--text-primary);
            font-family: 'Microsoft JhengHei', 'Segoe UI', Roboto, Helvetica, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #game-wrapper {
            position: relative;
            width: 1000px;
            height: 600px;
            background: var(--bg-panel);
            border-radius: 24px;
            box-shadow: 0 0 40px rgba(0, 243, 255, 0.1), inset 0 0 0 1px var(--glass-border);
            backdrop-filter: blur(10px);
            overflow: hidden;
        }

        canvas { display: block; width: 100%; height: 100%; }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            justify-content: space-between; padding: 30px; box-sizing: border-box; z-index: 5;
        }

        .hud-bar {
            display: flex; justify-content: space-between; align-items: center;
            font-size: 24px; font-weight: 800; letter-spacing: 1px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
        }
        .lives-display { color: var(--accent-red); font-size: 28px; letter-spacing: 4px; }

        #center-notify {
            position: absolute; top: 45%; left: 50%; transform: translate(-50%, -50%);
            font-size: 100px; font-weight: 900; text-transform: uppercase; font-style: italic;
            opacity: 0; white-space: nowrap;
            filter: drop-shadow(0 0 30px rgba(0, 243, 255, 0.8));
            transition: all 0.3s ease-out;
        }

        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 10, 20, 0.85); backdrop-filter: var(--blur);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 10; opacity: 0; pointer-events: none; transition: opacity 0.4s;
        }
        .screen.active { opacity: 1; pointer-events: auto; }

        h1 {
            font-size: 64px; margin-bottom: 10px; font-weight: 900; letter-spacing: 4px;
            background: linear-gradient(to right, #fff, var(--accent-cyan));
            -webkit-background-clip: text; color: transparent;
            text-shadow: 0 10px 30px rgba(0, 243, 255, 0.3);
        }

        .subtitle { color: var(--text-secondary); font-size: 18px; margin-bottom: 30px; letter-spacing: 2px; text-transform: uppercase; }

        .control-panel {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px;
            width: 800px; padding: 30px; margin-bottom: 30px;
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--glass-border); border-radius: 16px;
        }
        .control-group.full { grid-column: span 2; }

        label { font-size: 12px; color: var(--accent-cyan); margin-bottom: 8px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; }

        select, .btn {
            padding: 12px; border-radius: 8px; background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--glass-border); color: white; font-family: inherit;
            font-size: 16px; cursor: pointer; transition: 0.2s; outline: none;
        }
        select:hover { border-color: var(--accent-cyan); background: rgba(0,0,0,0.6); }

        .toggle-wrapper { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; background: rgba(0,0,0,0.4); border-radius: 8px; padding: 4px; gap: 5px;}
        
        .toggle-btn {
            padding: 10px 5px; border: none; background: transparent;
            color: var(--text-secondary); cursor: pointer; border-radius: 6px;
            font-weight: 700; transition: 0.2s; font-size: 14px;
        }
        .toggle-btn:hover { background: rgba(255,255,255,0.05); }
        .toggle-btn.active { background: rgba(255,255,255,0.15); color: var(--accent-cyan); box-shadow: 0 0 15px rgba(0,243,255,0.2); }
        
        .toggle-btn[data-mode="vanishing"].active { color: var(--accent-purple); box-shadow: 0 0 15px rgba(217, 70, 239, 0.3); }
        .toggle-btn[data-mode="survival"].active { color: var(--accent-orange); box-shadow: 0 0 15px rgba(255, 145, 0, 0.3); }
        .toggle-btn[data-mode="vanishing-survival"].active { color: var(--accent-red); box-shadow: 0 0 15px rgba(255, 0, 85, 0.3); }

        .btn-start {
            padding: 18px 70px; font-size: 24px; font-weight: 800;
            background: linear-gradient(90deg, var(--accent-cyan), #0066ff);
            border: none; color: #000; box-shadow: 0 0 30px rgba(0, 243, 255, 0.4);
            transform: scale(1); transition: 0.2s;
        }
        .btn-start:hover { transform: scale(1.05); box-shadow: 0 0 50px rgba(0, 243, 255, 0.6); color: white; }

        /* Result Screen */
        .result-summary-bar {
            display: flex; justify-content: center; gap: 20px; margin-bottom: 25px;
            background: rgba(255,255,255,0.05); padding: 12px 30px; border-radius: 50px;
            border: 1px solid var(--glass-border); width: fit-content;
        }
        .setting-item { display: flex; flex-direction: column; align-items: center; min-width: 80px; border-right: 1px solid rgba(255,255,255,0.1); padding: 0 15px; }
        .setting-item:last-child { border-right: none; }
        .setting-label { font-size: 10px; color: var(--text-secondary); font-weight: 700; margin-bottom: 4px; letter-spacing: 1px; }
        .setting-val { font-size: 16px; color: var(--accent-cyan); font-weight: 700; text-shadow: 0 0 10px rgba(0, 243, 255, 0.3); }

        .final-score-box {
            font-size: 64px; font-weight: 900; margin-bottom: 10px; color: white;
            text-shadow: 0 0 30px rgba(255,255,255,0.4); font-variant-numeric: tabular-nums;
        }
        
        .main-score-circle {
            width: 220px; 
            height: 220px; 
            border-radius: 50%;
            border: 10px solid rgba(255,255,255,0.1);
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center;
            margin-bottom: 40px; 
            position: relative; 
            background: rgba(0,0,0,0.3);
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }
        
        .score-percent { 
            font-size: 56px; 
            font-weight: 900; 
            color: white; 
            margin-bottom: 5px;
        }
        
        .score-label {
            font-size: 14px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .rank-badge {
            position: absolute; 
            bottom: -25px; 
            background: white; 
            color: black;
            font-weight: 900; 
            padding: 5px 30px; 
            border-radius: 30px; 
            font-size: 32px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            z-index: 2;
        }

        .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; width: 100%; margin-bottom: 20px; }
        .stat-box { background: rgba(255,255,255,0.05); padding: 15px; border-radius: 12px; text-align: center; border: 1px solid var(--glass-border); }
        .stat-label { font-size: 12px; color: var(--text-secondary); margin-bottom: 5px; font-weight: 700; }
        .stat-value { font-size: 24px; font-weight: 800; }
        
        .perfect-col { color: var(--accent-cyan); text-shadow: 0 0 10px var(--accent-cyan); }
        .miss-col { color: var(--accent-red); text-shadow: 0 0 10px var(--accent-red); }

        /* Hit Animation */
        .hit-popup {
            position: absolute; font-weight: 900; font-size: 48px;
            transform: translate(-50%, -50%); pointer-events: none;
            animation: popUp 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            z-index: 20; text-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        @keyframes popUp {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5) rotate(-10deg); }
            50% { opacity: 1; transform: translate(-50%, -80%) scale(1.2) rotate(0deg); }
            100% { opacity: 0; transform: translate(-50%, -120%) scale(1) rotate(5deg); }
        }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <canvas id="gameCanvas" width="1000" height="600"></canvas>

        <div id="ui-layer">
            <div class="hud-bar">
                <div id="info-display">Round 1</div>
                <div id="lives-display" class="lives-display"></div>
                <div id="score-display">000000</div>
            </div>
            <div id="center-notify"></div>
        </div>

        <div id="menu-screen" class="screen active">
            <h1>藍循節奏大師</h1>
            <p class="subtitle">極致動感．節奏訓練</p>

            <div class="control-panel">
                <div class="control-group full">
                    <label>遊戲模式</label>
                    <div class="toggle-wrapper">
                        <button class="toggle-btn active" data-mode="fixed" id="btn-fixed" onclick="setMode('fixed')">練習</button>
                        <button class="toggle-btn" data-mode="vanishing" id="btn-vanishing" onclick="setMode('vanishing')">消失</button>
                        <button class="toggle-btn" data-mode="survival" id="btn-survival" onclick="setMode('survival')">生存</button>
                        <button class="toggle-btn" data-mode="vanishing-survival" id="btn-vanishing-survival" onclick="setMode('vanishing-survival')">消失生存</button>
                    </div>
                    <div id="mode-desc" style="font-size:12px; color:#94a3b8; margin-top:10px; text-align:center; min-height:15px;">
                        標準練習模式，顯示所有音符，無死亡機制。
                    </div>
                </div>

                <div class="control-group" id="round-group">
                    <label>長度</label>
                    <select id="round-select">
                        <option value="4">4 回合 (Short)</option>
                        <option value="6" selected>6 回合 (Standard)</option>
                        <option value="10">10 回合 (Long)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>速度</label>
                    <select id="speed-select">
                        <option value="70">慢板 Adagio (70)</option>
                        <option value="95" selected>中板 Moderato (95)</option>
                        <option value="120">快板 Allegro (120)</option>
                    </select>
                </div>

                <div class="control-group full">
                    <label>難度</label>
                    <select id="diff-select">
                        <option value="easy">簡單 (四分/二分)</option>
                        <option value="normal">普通 (八分音符)</option>
                        <option value="hard">困難 (十六分/附點)</option>
                        <option value="master">達人 (切分音/混合)</option>
                    </select>
                </div>
            </div>
            <button class="btn btn-start" onclick="startGame()">開始遊戲</button>
        </div>

        <div id="result-screen" class="screen">
            <h1 style="font-size:40px; margin-bottom:25px;">訓練結束</h1>

            <div class="result-summary-bar">
                <div class="setting-item">
                    <span class="setting-label">模式</span>
                    <span class="setting-val" id="res-mode">練習</span>
                </div>
                <div class="setting-item">
                    <span class="setting-label">長度</span>
                    <span class="setting-val" id="res-len">6 R</span>
                </div>
                <div class="setting-item">
                    <span class="setting-label">速度</span>
                    <span class="setting-val" id="res-spd">中板</span>
                </div>
                <div class="setting-item">
                    <span class="setting-label">難度</span>
                    <span class="setting-val" id="res-diff">普通</span>
                </div>
            </div>

            <div style="text-align:center;">
                <div class="final-score-box" id="end-score-val">000000</div>
            </div>

            <div class="main-score-circle" id="score-circle">
                <div class="score-percent" id="result-percent">0%</div>
                <div class="score-label">成功率</div>
                <div class="rank-badge" id="result-rank">S</div>
            </div>

            <div class="control-panel" style="margin-bottom: 20px; padding: 20px; width: 500px;">
                <div class="stats-grid" style="margin-bottom:0;">
                    <div class="stat-box perfect-col">
                        <div class="stat-label">PERFECT</div><div class="stat-value" id="count-perfect">0</div>
                    </div>
                    <div class="stat-box good-col">
                        <div class="stat-label" style="color:var(--accent-green)">GOOD</div><div class="stat-value" id="count-good">0</div>
                    </div>
                    <div class="stat-box poor-col">
                        <div class="stat-label" style="color:var(--accent-yellow)">POOR</div><div class="stat-value" id="count-poor">0</div>
                    </div>
                    <div class="stat-box miss-col">
                        <div class="stat-label">MISS</div><div class="stat-value" id="count-miss">0</div>
                    </div>
                </div>
            </div>
            <button class="btn btn-start" onclick="showMenu()">返回選單</button>
        </div>
    </div>

    <script>
        // --- VFX & AUDIO (Standard) ---
        const VFX={particles:[],shockwaves:[],pulseIntensity:0,init(){this.particles=[];this.shockwaves=[];for(let i=0;i<60;i++)this.particles.push({x:Math.random()*1000,y:Math.random()*600,size:Math.random()*2+0.5,speed:Math.random()*2+0.5,alpha:Math.random()*0.5+0.1})},triggerPulse(){this.pulseIntensity=1.0;const w=document.getElementById('game-wrapper');w.style.transform="scale(1.01)";setTimeout(()=>w.style.transform="scale(1)",50)},addShockwave(x,y,color){this.shockwaves.push({x:x,y:y,radius:10,alpha:1,color:color,width:5})},update(ctx){const pulseF=1+(this.pulseIntensity*0.5);this.particles.forEach(p=>{p.x-=p.speed*pulseF*2;if(p.x<0){p.x=1000;p.y=Math.random()*600}ctx.fillStyle=`rgba(255,255,255,${p.alpha+(this.pulseIntensity*0.2)})`;ctx.beginPath();ctx.arc(p.x,p.y,p.size*pulseF,0,Math.PI*2);ctx.fill()});for(let i=this.shockwaves.length-1;i>=0;i--){let sw=this.shockwaves[i];sw.radius+=8;sw.alpha-=0.05;sw.width*=0.9;if(sw.alpha<=0)this.shockwaves.splice(i,1);else{ctx.beginPath();ctx.arc(sw.x,sw.y,sw.radius,0,Math.PI*2);ctx.strokeStyle=sw.color;ctx.globalAlpha=sw.alpha;ctx.lineWidth=sw.width;ctx.stroke();ctx.globalAlpha=1}}this.pulseIntensity*=0.9}};
        const AudioEngine={ctx:null,noiseBuf:null,init(){if(!this.ctx){this.ctx=new(window.AudioContext||window.webkitAudioContext)();const size=this.ctx.sampleRate*2;const buf=this.ctx.createBuffer(1,size,this.ctx.sampleRate);const d=buf.getChannelData(0);for(let i=0;i<size;i++)d[i]=Math.random()*2-1;this.noiseBuf=buf}if(this.ctx.state==='suspended')this.ctx.resume()},play(type,time){if(!this.ctx)return;const t=time||this.ctx.currentTime;if(type==='teacher')this.synthWoodblock(t);if(type==='player')this.synthDrum(t);if(type==='metro'){this.synthRim(t);const delay=(t-this.ctx.currentTime)*1000;if(delay>=0)setTimeout(()=>VFX.triggerPulse(),delay)}},synthWoodblock(t){const osc=this.ctx.createOscillator();const g=this.ctx.createGain();const f=this.ctx.createBiquadFilter();f.type='bandpass';f.frequency.value=800;f.Q.value=8;osc.connect(f);f.connect(g);g.connect(this.ctx.destination);osc.frequency.setValueAtTime(850,t);osc.frequency.exponentialRampToValueAtTime(800,t+0.1);g.gain.setValueAtTime(0,t);g.gain.linearRampToValueAtTime(1,t+0.005);g.gain.exponentialRampToValueAtTime(0.001,t+0.15);osc.start(t);osc.stop(t+0.2)},synthDrum(t){const osc=this.ctx.createOscillator();const g=this.ctx.createGain();osc.connect(g);g.connect(this.ctx.destination);osc.frequency.setValueAtTime(150,t);osc.frequency.exponentialRampToValueAtTime(40,t+0.2);g.gain.setValueAtTime(1,t);g.gain.exponentialRampToValueAtTime(0.01,t+0.3);osc.start(t);osc.stop(t+0.3);const n=this.ctx.createBufferSource();n.buffer=this.noiseBuf;const nf=this.ctx.createBiquadFilter();nf.type='lowpass';nf.frequency.value=1200;const ng=this.ctx.createGain();n.connect(nf);nf.connect(ng);ng.connect(this.ctx.destination);ng.gain.setValueAtTime(0.8,t);ng.gain.exponentialRampToValueAtTime(0.001,t+0.05);n.start(t);n.stop(t+0.05)},synthRim(t){const osc=this.ctx.createOscillator();const g=this.ctx.createGain();const f=this.ctx.createBiquadFilter();f.type='highpass';f.frequency.value=2000;osc.type='square';osc.connect(f);f.connect(g);g.connect(this.ctx.destination);osc.frequency.setValueAtTime(800,t);g.gain.setValueAtTime(0.08,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.05);osc.start(t);osc.stop(t+0.1)}};

        // --- GAME LOGIC ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const HIT_X = 200;
        const SPAWN_X = 1000;
        const PHASE_BEATS = 4;
        const WINDOWS = { PERFECT: 0.06, GOOD: 0.12, MISS: 0.25 };

        let gameState = 'MENU';
        let config = { mode: 'fixed', rounds: 6, bpm: 95, difficulty: 'normal' };
        let session = { score: 0, round: 0, lives: 3, notes: [], nextTime: 0, animId: null, stats: { perfect: 0, good: 0, poor: 0, miss: 0 } };
        let gameTimeouts = []; 

        const getBeatSec = () => 60 / config.bpm;
        const getPxPerSec = () => (SPAWN_X - HIT_X) / (PHASE_BEATS * getBeatSec());

        const PATTERNS = {
            easy: [[1], [2]],
            normal: [[1], [0.5, 0.5], [2]],
            hard: [[1], [0.5, 0.5], [2], [0.25, 0.25, 0.25, 0.25], [0.5, 0.25, 0.25], [1.5, 0.5], [0.75, 0.25]],
            master: [[0.25, 0.5, 0.25], [0.25, 0.75], [0.5, 0.5], [0.25, 0.25, 0.25, 0.25], [1], [1.5, 0.5]]
        };

        function setGameTimeout(callback, delay) {
            const id = setTimeout(callback, delay);
            gameTimeouts.push(id);
            return id;
        }

        function clearGameTimeouts() {
            gameTimeouts.forEach(id => clearTimeout(id));
            gameTimeouts = [];
        }

        function generatePattern(diff) {
            let beats = []; let filled = 0;
            const blocks = PATTERNS[diff];
            while(filled < 4) {
                let remaining = 4 - filled;
                let valid = blocks.filter(b => b.reduce((a,c)=>a+c,0) <= remaining + 0.001);
                if(diff==='normal' && remaining===0.5) valid=[[0.5]];
                if(valid.length===0) valid=[[remaining]];
                let choice = valid[Math.floor(Math.random()*valid.length)];
                choice.forEach(d => { beats.push(filled); filled += d; });
            }
            return beats;
        }

        function setMode(m) {
            config.mode = m;
            document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${m}`).classList.add('active');
            
            const rg = document.getElementById('round-group');
            const desc = document.getElementById('mode-desc');
            
            const isSurvival = m === 'survival' || m === 'vanishing-survival';
            if(isSurvival) { 
                rg.style.opacity='0.3'; rg.style.pointerEvents='none';
            } else { 
                rg.style.opacity='1'; rg.style.pointerEvents='auto'; 
            }

            if (m === 'fixed') desc.innerText = "練習模式：顯示所有音符，固定回合，無死亡。";
            else if (m === 'vanishing') desc.innerText = "消失模式：只顯示第1顆音符，考驗聽力記憶，無死亡。";
            else if (m === 'survival') desc.innerText = "生存模式：無限回合，3 顆生命值，失誤扣血。";
            else if (m === 'vanishing-survival') desc.innerText = "極限挑戰：消失音符 + 生存模式！";
        }

        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        function startGame() {
            if(document.activeElement) document.activeElement.blur();
            clearGameTimeouts();
            if(session.animId) cancelAnimationFrame(session.animId);

            AudioEngine.init(); VFX.init();
            config.bpm = parseInt(document.getElementById('speed-select').value);
            config.difficulty = document.getElementById('diff-select').value;
            const isSurvival = config.mode === 'survival' || config.mode === 'vanishing-survival';
            config.rounds = isSurvival ? Infinity : parseInt(document.getElementById('round-select').value);
            
            session = { score: 0, round: 0, lives: 3, notes: [], nextTime: AudioEngine.ctx.currentTime + 1.0, animId: null, stats: { perfect: 0, good: 0, poor: 0, miss: 0 } };
            gameState = 'PLAYING';
            
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            updateHUD(); schedule(); render();
        }

        function schedule() {
            if(gameState !== 'PLAYING') return;
            const isSurvival = config.mode === 'survival' || config.mode === 'vanishing-survival';
            if(!isSurvival && session.round >= config.rounds) { endGame("TRAINING COMPLETE"); return; }

            const now = session.nextTime;
            const BEAT = getBeatSec();
            const PHASE = BEAT * PHASE_BEATS;
            session.nextTime += (PHASE * 2);

            const pattern = generatePattern(config.difficulty);
            pattern.forEach(b => AudioEngine.play('teacher', now + b * BEAT));

            const playStart = now + PHASE;
            pattern.forEach((b, index) => {
                session.notes.push({ 
                    target: playStart + b * BEAT, 
                    hit: false, 
                    missed: false,
                    index: index 
                });
            });

            setGameTimeout(() => {
                if(gameState==='PLAYING') {
                    session.round++; updateHUD();
                    notify("LISTEN", "var(--accent-cyan)");
                    AudioEngine.play('metro', AudioEngine.ctx.currentTime);
                }
            }, (now - AudioEngine.ctx.currentTime)*1000);

            setGameTimeout(() => {
                if(gameState==='PLAYING') {
                    let col = (config.mode.includes('vanishing')) ? "var(--accent-purple)" : "var(--accent-orange)";
                    if (config.mode === 'vanishing-survival') col = "var(--accent-red)";
                    notify("PLAY", col);
                    AudioEngine.play('metro', AudioEngine.ctx.currentTime);
                }
            }, (playStart - AudioEngine.ctx.currentTime)*1000);

            setGameTimeout(schedule, (session.nextTime - AudioEngine.ctx.currentTime - 0.1)*1000);
        }

        function render() {
            if(gameState !== 'PLAYING') return;
            const now = AudioEngine.ctx.currentTime;
            const speed = getPxPerSec();
            const beatSec = getBeatSec();
            const isVanishingMode = config.mode === 'vanishing' || config.mode === 'vanishing-survival';
            const isSurvivalMode = config.mode === 'survival' || config.mode === 'vanishing-survival';

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            VFX.update(ctx);

            const Y = 300;
            const trackAlpha = 0.5 + (VFX.pulseIntensity * 0.2);
            ctx.shadowBlur = 20 * trackAlpha;
            ctx.shadowColor = `rgba(0, 243, 255, ${trackAlpha * 0.5})`;
            ctx.fillStyle = `rgba(15, 23, 42, ${trackAlpha})`;
            ctx.fillRect(0, Y-60, canvas.width, 120);
            ctx.shadowBlur = 0;
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 + (VFX.pulseIntensity * 0.2)})`; 
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, Y-60); ctx.lineTo(canvas.width, Y-60); ctx.moveTo(0, Y+60); ctx.lineTo(canvas.width, Y+60); ctx.stroke();

            ctx.beginPath(); ctx.arc(HIT_X, Y, 45 + (VFX.pulseIntensity * 5), 0, Math.PI*2);
            ctx.strokeStyle = "rgba(255,255,255,0.9)"; ctx.lineWidth = 4; ctx.stroke();
            ctx.fillStyle = "rgba(255,255,255,0.05)"; ctx.fill();
            ctx.fillStyle = "#94a3b8"; ctx.font = "bold 12px Segoe UI"; ctx.fillText("HIT ZONE", HIT_X - 28, Y + 75);

            session.notes.forEach(n => {
                if(n.hit) return;
                if(isVanishingMode && n.index > 0) { } else {
                    const dt = n.target - now;
                    const x = HIT_X + (dt * speed);
                    if(x > -50 && x < canvas.width && !n.missed) {
                        const isIncoming = dt <= (PHASE_BEATS * beatSec);
                        let color = isIncoming ? "#ff9100" : "#00f3ff";
                        if(isVanishingMode && isIncoming) color = "#d946ef"; 
                        if(config.mode === 'vanishing-survival' && isIncoming) color = "#be123c";
                        ctx.shadowBlur = 15; ctx.shadowColor = color; ctx.fillStyle = color;
                        ctx.beginPath(); ctx.arc(x, Y, 35, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(x, Y, 15, 0, Math.PI*2); ctx.fill();
                        ctx.strokeStyle = "white"; ctx.lineWidth = 3; ctx.stroke(); ctx.shadowBlur = 0;
                    }
                }
                const dt = n.target - now;
                if(dt < -WINDOWS.MISS && !n.missed) {
                    n.missed = true; session.stats.miss++;
                    feedback("MISS", "var(--accent-red)");
                    if(isSurvivalMode) loseLife();
                }
            });
            
            session.animId = requestAnimationFrame(render);
        }

        function handleInput() {
            if(gameState !== 'PLAYING') return;
            const now = AudioEngine.ctx.currentTime;
            AudioEngine.play('player', now);
            VFX.pulseIntensity = 0.5;
            const isSurvivalMode = config.mode === 'survival' || config.mode === 'vanishing-survival';

            let bestNote = null; let minDiff = Infinity;
            session.notes.forEach(n => {
                if(!n.hit && !n.missed) {
                    const d = Math.abs(n.target - now);
                    if(d < minDiff) { minDiff = d; bestNote = n; }
                }
            });

            if(bestNote && minDiff < WINDOWS.MISS) {
                bestNote.hit = true;
                if(minDiff < WINDOWS.PERFECT) {
                    session.score += 100; session.stats.perfect++;
                    feedback("PERFECT", "var(--accent-cyan)"); VFX.addShockwave(HIT_X, 300, "var(--accent-cyan)");
                } else if(minDiff < WINDOWS.GOOD) {
                    session.score += 50; session.stats.good++;
                    feedback("GOOD", "var(--accent-green)");
                } else {
                    session.stats.poor++;
                    feedback("POOR", "var(--accent-yellow)");
                    if(isSurvivalMode) loseLife();
                }
                updateHUD();
            }
        }

        function loseLife() {
            session.lives--; updateHUD();
            const wrap = document.getElementById('game-wrapper');
            wrap.style.boxShadow = "inset 0 0 100px var(--accent-red)";
            setTimeout(() => wrap.style.boxShadow = "0 0 40px rgba(0, 243, 255, 0.1), inset 0 0 0 1px rgba(255,255,255,0.1)", 150);
            if(session.lives <= 0) endGame("FAILED");
        }

        function notify(text, color) {
            const el = document.getElementById('center-notify');
            el.innerText = text; el.style.color = color; el.style.opacity = 1;
            el.style.transform = "translate(-50%, -50%) scale(1.2)";
            setTimeout(() => { el.style.opacity = 0; el.style.transform = "translate(-50%, -50%) scale(1)"; }, 600);
        }

        function feedback(text, color) {
            const el = document.createElement('div');
            el.className = 'hit-popup'; el.innerText = text; el.style.color = color;
            el.style.left = HIT_X + 'px'; el.style.top = '220px';
            document.getElementById('game-wrapper').appendChild(el);
            setTimeout(() => el.remove(), 500);
        }

        function updateHUD() {
            document.getElementById('score-display').innerText = session.score.toString().padStart(6, '0');
            let rTxt = `ROUND ${session.round}`;
            const isFixed = config.mode === 'fixed' || config.mode === 'vanishing';
            if(isFixed) rTxt += ` / ${config.rounds}`;
            document.getElementById('info-display').innerText = rTxt;
            let h = ""; const isSurvival = config.mode === 'survival' || config.mode === 'vanishing-survival';
            if(isSurvival) for(let i=0; i<session.lives; i++) h += "❤ ";
            document.getElementById('lives-display').innerText = h;
        }

        function endGame(status) {
            gameState = 'END'; showScreen('result-screen');
            clearGameTimeouts();
            const { perfect, good, poor, miss } = session.stats;
            const total = perfect + good + poor + miss;
            
            // Populate Summary
            let mTxt = ""; 
            if(config.mode==='fixed') mTxt="練習"; else if(config.mode==='vanishing') mTxt="消失";
            else if(config.mode==='survival') mTxt="生存"; else mTxt="消失生存";
            document.getElementById('res-mode').innerText = mTxt;

            let lTxt = (config.mode.includes('survival')) ? "∞" : config.rounds + " R";
            document.getElementById('res-len').innerText = lTxt;

            let sTxt = "";
            if(config.bpm===70) sTxt="慢板"; else if(config.bpm===95) sTxt="中板"; else sTxt="快板";
            document.getElementById('res-spd').innerText = sTxt;

            let dTxt = "";
            if(config.difficulty==='easy') dTxt="簡單"; else if(config.difficulty==='normal') dTxt="普通";
            else if(config.difficulty==='hard') dTxt="困難"; else dTxt="達人";
            document.getElementById('res-diff').innerText = dTxt;

            document.getElementById('end-score-val').innerText = session.score.toString().padStart(6, '0');
            document.getElementById('count-perfect').innerText = perfect;
            document.getElementById('count-good').innerText = good;
            document.getElementById('count-poor').innerText = poor;
            document.getElementById('count-miss').innerText = miss;

            let acc = total === 0 ? 0 : ((perfect + good) / total) * 100;
            acc = Math.round(acc);
            document.getElementById('result-percent').innerText = acc + "%";
            
            let rank = 'D'; let color = 'var(--accent-red)';
            if (acc === 100) { rank = 'S'; color = 'var(--accent-cyan)'; }
            else if (acc >= 90) { rank = 'A'; color = 'var(--accent-green)'; }
            else if (acc >= 76) { rank = 'B'; color = 'var(--accent-yellow)'; }
            else if (acc >= 60) { rank = 'C'; color = 'var(--accent-orange)'; }
            
            const badge = document.getElementById('result-rank');
            badge.innerText = rank; badge.style.background = color; badge.style.boxShadow = `0 0 20px ${color}`;
            document.getElementById('score-circle').style.borderColor = color;
        }

        function showMenu() { showScreen('menu-screen'); }

        window.addEventListener('keydown', e => {
            const key = e.key.toLowerCase();
            if([' ','f','j','d','k'].includes(key)) {
                e.preventDefault();
                if(e.repeat) return;
                handleInput();
            }
        });
        window.addEventListener('mousedown', e => { 
            if(!e.target.closest('button') && !e.target.closest('select')) handleInput(); 
        });

    </script>
</body>
</html>